<!DOCTYPE html>
<html>
<head>
    <title>Random Art Memory</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="icon" href="data:,">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            z-index: 10;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        .control-btn {
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 20px;
            margin: 5px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            touch-action: none;
            user-select: none;
            transition: background 0.2s;
        }
        .control-btn:active {
            background: rgba(255, 255, 255, 0.6);
        }
        #color-btn {
            background: #ff0000;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 20;
            text-align: center;
        }
        #progress-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border: 1px solid #fff;
            margin-top: 10px;
        }
        #progress-fill {
            height: 100%;
            background: #4caf50;
            width: 0%;
            transition: width 0.3s;
        }
        #loading-error {
            color: red;
            margin-top: 10px;
            display: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: block;
        }
        @media (max-width: 768px) {
            .controls {
                bottom: 10px;
                gap: 10px;
            }
            .control-btn {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div id="loading">
        Loading... <br>
        <div id="progress-bar"><div id="progress-fill"></div></div>
        <div id="loading-error">Some images failed to load. Using placeholders.</div>
    </div>
    <div id="crosshair"></div>
    <div class="controls">
        <span class="control-btn" id="ml">‚Üê</span>
        <span class="control-btn" id="mf">‚Üë</span>
        <span class="control-btn" id="mb">‚Üì</span>
        <span class="control-btn" id="mr">‚Üí</span>
        <span class="control-btn" id="jump">‚§¥</span>
        <span class="control-btn" id="rocket">üöÄ</span>
        <span class="control-btn" id="color-btn">üé®</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        if (typeof THREE === "undefined") {
            console.error("Three.js failed to load. Please check the CDN.");
            document.body.innerHTML = "<p>Error: Unable to load Three.js. Please try again later.</p>";
            throw new Error("Three.js not loaded");
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const roomSize = 12;
        const wallHeight = 8;
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
        const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
        const floor = [
            new THREE.Mesh(floorGeometry, new THREE.MeshBasicMaterial({ color: 0x808080 })),
            new THREE.Mesh(floorGeometry, new THREE.MeshBasicMaterial({ color: 0x606060 }))
        ];
        floor[0].rotation.x = -Math.PI / 2;
        floor[1].rotation.x = -Math.PI / 2;
        floor[0].position.x = roomSize;
        floor.forEach(f => scene.add(f));

        const walls = [
            { size: [roomSize, wallHeight], pos: [0, wallHeight / 2, -6], rot: [0, 0, 0] },
            { size: [roomSize, wallHeight], pos: [0, wallHeight / 2, 6], rot: [0, Math.PI, 0] },
            { size: [roomSize, wallHeight], pos: [-6, wallHeight / 2, 0], rot: [0, Math.PI / 2, 0] },
            { size: [roomSize / 3, wallHeight], pos: [6, wallHeight / 2, -4], rot: [0, -Math.PI / 2, 0] },
            { size: [roomSize / 3, wallHeight], pos: [6, wallHeight / 2, 4], rot: [0, -Math.PI / 2, 0] },
            { size: [roomSize, wallHeight], pos: [roomSize, wallHeight / 2, -6], rot: [0, 0, 0] },
            { size: [roomSize, wallHeight], pos: [roomSize, wallHeight / 2, 6], rot: [0, Math.PI, 0] },
            { size: [roomSize, wallHeight], pos: [18, wallHeight / 2, 0], rot: [0, -Math.PI / 2, 0] }
        ].map(w => {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(...w.size), wallMaterial);
            mesh.position.set(...w.pos);
            mesh.rotation.set(...w.rot);
            scene.add(mesh);
            return mesh;
        });

        const roof = new THREE.Mesh(
            new THREE.PlaneGeometry(roomSize * 2, roomSize),
            new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide })
        );
        roof.rotation.x = Math.PI / 2;
        roof.position.set(6, wallHeight, 0);
        scene.add(roof);

        const inscriptions = {
            r1: {
                rear: [
                    "0c605005b4c3e79cd5310a8fb93918e5e2c2bfbed8077e0a297562c5c7fcea26i0",
                    "ca0a1c1e3c5e7f7743e1aa1115b5c18604614e641613a0b5a85deb3a032c893ci0",
                    "cf33d696f3172f1bb9615bf28a9fcf8697c8f8e0bd10abd2a5b1e82e18ab0b1bi0",
                    "4ad74184e62077ef9c89e622ec495ba2f50e86f33709666b5f8eb6ca5b86e5a3i0"
                ],
                front: [
                    "535413a5997d4462e2348b579d10ee229ed99753f4aa80e81f81c922b30d22f6i0",
                    "4a789931962905e4984bda3f16884760e3d96482794979feded261056e607cc7i0",
                    "083703b7140339aa1315bb1aeaf23618448cadbe278f41298447c81e3c28db44i0",
                    "b808bdc26cbab54c7cd7f6af6f904cbde83142d31922f9607e6dbe3b478ad0eai0"
                ],
                left: [
                    "356252054f3ae335edb986973923e6d39d64bf386093eae390993f3b45cf4459i0",
                    "5a5379c13f9a6d02c214e1debdf96c804c01412213d3f1b99aecfc0e14adf383i0",
                    "80b9f2b3bfc69b45ea605705374dddefd207c6f9ac77c5a065af09ba69f48849i0",
                    "e0b28096d551e1e33eb5328b059e1f44800fabd2c615d6f404b9318b9b4c7c9di0"
                ]
            },
            r2: {
                front: [
                    "547a594d81c339b9424a92c8cf7781e7960250a0d63cc73ac45445e88505ff6ei0",
                    "72e45ebbe78c7706062528a6492dfe3edc721ce0f7491419eb65044a6839efc0i0",
                    "bbb59aad913ff20412a4730aa6a81601399e20bb266ecfe9365243d6b3b6c2bci0",
                    "3c36a9977e31283b44383f5befc70e440f47215081fc92e3b1e3051a5b9c6d0bi0"
                ],
                rear: [
                    "56a2bc9b36dfbf20a1ae7903879feb450ec29cb26ed105f5daf44f470bcbf07ci0",
                    "5ffc626783375d6ec740e3275710151f23e365ce6380f261d03f734affc748d5i0",
                    "a6dbe65d150246c98013fa78d9f0a0ce056aa0e0d975727656e7ea49215ee99ai0",
                    "7a61c2db0ea52adf65f32e1f6811e1321b0d1d1faef1f98d9ba2f456c28638aai0"
                ],
                right: [
                    "bdaa83cf903c75d8e5e902290e0bd5e28be877620720b836388e0c3f9620d7afi0",
                    "e43b916d32afa6350a80451d0cb805583173ae86ee0ea19fe8d56b6e7722303di0",
                    "e8cc1124aa8625422f7063514cd21dc31f73912278d9dff2d37fb13e73225029i0",
                    "55aef05f37ca25321f7bb1685338ada17d4e924b32aada4f907d85e97fd3580fi0"
                ]
            },
            r3: {
                wleft_back: [
                    "d4b4e3d6c84328272069d7523ab90787440076f77a69593f78c1cebcbf25b377i0"
                ],
                wleft_front: [
                    "a8613b14c642b931a1e5f4a7c89cfc354ad34a2747944aa33a2456f507ad7cadi0"
                ],
                wright_front: [
                    "b774ea2c9c7fe9b723dc22134aff58ae29383447f4ee40924ccfff49ee79c246i0"
                ],
                wright_back: [
                    "f7871878b2346a4c7821bacc9ca8491c0f1ec33f01aca5b1538af7b84bbc1836i0"
                ]
            },
            r4: {
                up_face: [
                    "bd34487b6c5ef9e76f99db62d1ad6c5cdeb2998e43af475164a23e3fec247ecci0",
                    "3677bed81dd0b8c89a265ad87689a6fd9eef3275d5d0674fea13c1cb845c3f69i0",
                    "9d52f3e2b411255fd20800109df169fcaebc314f10a256a4e9509742f8ac6fc0i0"
                ],
                up_back: [
                    "779613bed07c74ce44a0f145a2042311d00f381dce4b552f23b6ccf33904d82bi0"
                ]

            }
        };

        const textureLoader = new THREE.TextureLoader();
        const baseUrl = "https://ordinals.com/content/";
        const fallbackUrl = "https://via.placeholder.com/300";
        const inscriptionsMeshes = [];
        let loadedTextures = 0;
        let failedTextures = 0;
        const totalTextures = Object.values(inscriptions).reduce((sum, room) =>
            sum + Object.values(room).reduce((s, arr) => s + arr.length, 0), 0) || 1;

        const addFrame = (url, x, y, z, rotation, index = 0) => {
            const loadTimeout = setTimeout(() => {
                console.warn(`Timeout loading texture: ${baseUrl + url}`);
                handleTextureError();
            }, 10000);

            textureLoader.load(
                baseUrl + url,
                texture => {
                    clearTimeout(loadTimeout);
                    console.log(`Loaded texture: ${baseUrl + url}`);
                    const mesh = new THREE.Mesh(
                        new THREE.PlaneGeometry(3, 3),
                        new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
                    );
                    mesh.position.set(x, y, z);
                    mesh.rotation.y = rotation;
                    scene.add(mesh);
                    inscriptionsMeshes.push(mesh);
                    loadedTextures++;
                    updateLoadingProgress();
                },
                undefined,
                error => {
                    clearTimeout(loadTimeout);
                    handleTextureError();
                }
            );

            function handleTextureError() {
                console.error(`Failed to load texture: ${baseUrl + url}`);
                failedTextures++;
                textureLoader.load(
                    fallbackUrl,
                    texture => {
                        const mesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(3, 3),
                            new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
                        );
                        mesh.position.set(x, y, z);
                        mesh.rotation.y = rotation;
                        scene.add(mesh);
                        inscriptionsMeshes.push(mesh);
                        loadedTextures++;
                        updateLoadingProgress();
                    },
                    undefined,
                    error => {
                        console.error(`Failed to load fallback texture: ${fallbackUrl}`);
                        const mesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(3, 3),
                            new THREE.MeshBasicMaterial({ color: 0x555555, side: THREE.DoubleSide })
                        );
                        mesh.position.set(x, y, z);
                        mesh.rotation.y = rotation;
                        scene.add(mesh);
                        inscriptionsMeshes.push(mesh);
                        loadedTextures++;
                        updateLoadingProgress();
                    }
                );
            }
        };

        // [Unchanged inscription loading]
        inscriptions.r1.rear.slice(0, 3).forEach((url, i) => addFrame(url, -4 + i * 4, 1.5, -5.9, 0));
        inscriptions.r1.front.forEach((url, i) => addFrame(url, -4 + i * 4, 1.5, 5.9, Math.PI));
        inscriptions.r1.left.forEach((url, i) => addFrame(url, -5.9, 1.5, -4 + i * 4, Math.PI / 2));
        inscriptions.r2.front.forEach((url, i) => addFrame(url, roomSize - 4 + i * 4, 1.5, 5.9, Math.PI));
        inscriptions.r2.rear.forEach((url, i) => addFrame(url, 8 + i * 4, 1.5, -5.9, 0));
        inscriptions.r2.right.forEach((url, i) => addFrame(url, roomSize + 5.9, 1.5, -4 + i * 4, -Math.PI / 2));
        inscriptions.r3.wleft_back.forEach((url, i) => addFrame(url, 6 + 0.01, 1.5, -4 + i * 2, -Math.PI / 2));
        inscriptions.r3.wleft_front.forEach((url, i) => addFrame(url, 6 - 0.01, 1.5, -4 + i * 2, Math.PI / 2));
        inscriptions.r3.wright_front.forEach((url, i) => addFrame(url, 6 - 0.01, 1.5, 4 + i * 2, Math.PI / 2));
        inscriptions.r3.wright_back.forEach((url, i) => addFrame(url, 6 + 0.01, 1.5, 4 + i * 2, -Math.PI / 2));

        inscriptions.r1.rear.slice(3).forEach((url, i) => addFrame(url, 0, 5.5, -5.9, 0));
        inscriptions.r1.front.slice(3).forEach((url, i) => addFrame(url, -4, 5.5, -5.9, 0));
        inscriptions.r1.left.slice(3).forEach((url, i) => addFrame(url, 4, 5.5, -5.9, 0));

        inscriptions.r2.front.slice(3).forEach((url, i) => addFrame(url,-4, 5.5, 5.9, Math.PI));
        inscriptions.r2.rear.slice(3).forEach((url, i) => addFrame(url, 0, 5.5, 5.9, Math.PI));
        inscriptions.r2.right.slice(3).forEach((url, i) => addFrame(url, 4, 5.5, 5.9, Math.PI));

        //take all elements of r4 from 0 and place them on z axis (which should be x)
        inscriptions.r4.up_face.slice(0).forEach((url, i) => addFrame(url, -5.9, 5.5, -4+i*4, Math.PI / 2));

        inscriptions.r4.up_back.slice(0).forEach((url, i) => addFrame(url, roomSize + 5.9, 5.5, -4 + i * 4, -Math.PI / 2));

        function updateLoadingProgress() {
            console.log(`Loaded: ${loadedTextures}/${totalTextures}, Failed: ${failedTextures}`);
            const progress = totalTextures > 0 ? (loadedTextures / totalTextures) * 100 : 100;
            document.getElementById("progress-fill").style.width = `${progress}%`;
            if (failedTextures > 0) {
                document.getElementById("loading-error").style.display = "block";
            }
            if (loadedTextures >= totalTextures) {
                setTimeout(() => {
                    document.getElementById("loading").remove();
                }, 500);
            }
        }

        // Rocket color management
        const rocketColors = [
            { name: "Red", hex: 0xff0000 },
            { name: "Blue", hex: 0x0000ff },
            { name: "Green", hex: 0x00ff00 },
            { name: "Yellow", hex: 0xffff00 },
            { name: "White", hex: 0xffffff },
            { name: "Black", hex: 0x000000 },
            { name: "Orange", hex: 0xffa500 }
        ];
        let currentColorIndex = 0;
        let rocketMaterial = new THREE.MeshBasicMaterial({ color: rocketColors[currentColorIndex].hex });
        let traceMaterial = new THREE.MeshBasicMaterial({ color: rocketColors[currentColorIndex].hex });
        const colorBtn = document.getElementById("color-btn");

        function updateColors() {
            currentColorIndex = (currentColorIndex + 1) % rocketColors.length;
            rocketMaterial = new THREE.MeshBasicMaterial({ color: rocketColors[currentColorIndex].hex });
            traceMaterial = new THREE.MeshBasicMaterial({ color: rocketColors[currentColorIndex].hex });
            colorBtn.style.background = `#${rocketColors[currentColorIndex].hex.toString(16).padStart(6, '0')}`;
        }

        colorBtn.addEventListener("click", updateColors);
        colorBtn.addEventListener("touchstart", e => {
            e.preventDefault();
            updateColors();
        });

        camera.position.set(0, 2, 0);
        camera.rotation.y = Math.PI;

        const rocketGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 16);
        const rockets = [];
        const rocketSpeed = 0.2;
        const maxRocketDistance = 20;
        const raycaster = new THREE.Raycaster();
        let mousePosition = new THREE.Vector2(0, 0);
        let touchPosition = new THREE.Vector2(0, 0);
        let isTouchDevice = false;

        addEventListener("touchstart", () => isTouchDevice = true, { once: true });

        const crosshair = document.getElementById("crosshair");
        addEventListener("mousemove", e => {
            mousePosition.x = (e.clientX / window.innerWidth) * 2 - 1;
            mousePosition.y = -(e.clientY / window.innerHeight) * 2 + 1;
            crosshair.style.left = `${e.clientX}px`;
            crosshair.style.top = `${e.clientY}px`;
        });
        addEventListener("touchmove", e => {
            if (!e.target.classList.contains("control-btn")) {
                touchPosition.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                touchPosition.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                crosshair.style.left = `${e.touches[0].clientX}px`;
                crosshair.style.top = `${e.touches[0].clientY}px`;
            }
        });

        let touchX = 0, mouseX = 0, dragging = 0;
        addEventListener("mousemove", e => {
            if (dragging && !e.target.classList.contains("control-btn")) {
                camera.rotation.y -= (e.clientX - mouseX) * 0.005;
                mouseX = e.clientX;
            }
        });
        addEventListener("mousedown", e => {
            if (!e.target.classList.contains("control-btn")) {
                dragging = 1;
                mouseX = e.clientX;
            }
        });
        addEventListener("mouseup", () => dragging = 0);
        addEventListener("touchstart", e => {
            if (!e.target.classList.contains("control-btn")) {
                touchX = e.touches[0].clientX;
            }
        });
        addEventListener("touchmove", e => {
            if (!e.target.classList.contains("control-btn")) {
                let deltaX = e.touches[0].clientX - touchX;
                if (Math.abs(deltaX) > 5) {
                    camera.rotation.y -= deltaX * 0.005;
                    touchX = e.touches[0].clientX;
                }
            }
        });

        function getDirectionFromScreenCoords(coords) {
            const vector = new THREE.Vector3(coords.x, coords.y, 0.5);
            vector.unproject(camera);
            return vector.sub(camera.position).normalize();
        }

        function launchRocket() {
            const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
            rocket.position.copy(camera.position);
            const direction = getDirectionFromScreenCoords(isTouchDevice ? touchPosition : mousePosition);
            rocket.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
            scene.add(rocket);
            rockets.push({
                mesh: rocket,
                direction: direction,
                distanceTraveled: 0
            });
        }

        function createTrace(position, normal) {
            const traceGeometry = new THREE.CircleGeometry(0.1, 16);
            const trace = new THREE.Mesh(traceGeometry, traceMaterial);
            trace.position.copy(position);
            trace.lookAt(position.clone().add(normal));
            trace.position.add(normal.multiplyScalar(0.01));
            scene.add(trace);
        }

        const moveSpeed = 0.05;
        const jumpSpeed = 0.2;
        const gravity = 0.01;
        let moveForward = 0, moveBackward = 0, moveLeft = 0, moveRight = 0, isJumping = false, velocityY = 0;
        const forwardBtn = document.getElementById("mf");
        const backwardBtn = document.getElementById("mb");
        const leftBtn = document.getElementById("ml");
        const rightBtn = document.getElementById("mr");
        const jumpBtn = document.getElementById("jump");
        const rocketBtn = document.getElementById("rocket");

        forwardBtn.addEventListener("touchstart", e => { e.preventDefault(); moveForward = 1; });
        forwardBtn.addEventListener("touchend", () => moveForward = 0);
        backwardBtn.addEventListener("touchstart", e => { e.preventDefault(); moveBackward = 1; });
        backwardBtn.addEventListener("touchend", () => moveBackward = 0);
        forwardBtn.addEventListener("mousedown", e => { e.preventDefault(); moveForward = 1; });
        forwardBtn.addEventListener("mouseup", () => moveForward = 0);
        backwardBtn.addEventListener("mousedown", e => { e.preventDefault(); moveBackward = 1; });
        backwardBtn.addEventListener("mouseup", () => moveBackward = 0);
        leftBtn.addEventListener("touchstart", e => { e.preventDefault(); moveLeft = 1; });
        leftBtn.addEventListener("touchend", () => moveLeft = 0);
        rightBtn.addEventListener("touchstart", e => { e.preventDefault(); moveRight = 1; });
        rightBtn.addEventListener("touchend", () => moveRight = 0);
        leftBtn.addEventListener("mousedown", e => { e.preventDefault(); moveLeft = 1; });
        leftBtn.addEventListener("mouseup", () => moveLeft = 0);
        rightBtn.addEventListener("mousedown", e => { e.preventDefault(); moveRight = 1; });
        rightBtn.addEventListener("mouseup", () => moveRight = 0);
        jumpBtn.addEventListener("touchstart", e => { e.preventDefault(); if (!isJumping) { isJumping = true; velocityY = jumpSpeed; } });
        jumpBtn.addEventListener("mousedown", e => { e.preventDefault(); if (!isJumping) { isJumping = true; velocityY = jumpSpeed; } });
        rocketBtn.addEventListener("touchstart", e => { e.preventDefault(); launchRocket(); });
        rocketBtn.addEventListener("mousedown", e => { e.preventDefault(); launchRocket(); });

        addEventListener("keydown", e => {
            if (e.key === "ArrowUp") moveForward = 1;
            if (e.key === "ArrowDown") moveBackward = 1;
            if (e.key === "ArrowLeft") moveLeft = 1;
            if (e.key === "ArrowRight") moveRight = 1;
            if (e.key === " " && !isJumping) { isJumping = true; velocityY = jumpSpeed; }
            if (e.key === "Enter") launchRocket();
            if (e.key === "c" || e.key === "Shift") { // Added Shift key
                updateColors();
            }
        });
        addEventListener("keyup", e => {
            if (e.key === "ArrowUp") moveForward = 0;
            if (e.key === "ArrowDown") moveBackward = 0;
            if (e.key === "ArrowLeft") moveLeft = 0;
            if (e.key === "ArrowRight") moveRight = 0;
        });

        function constrainCamera() {
            const heightLimit = 6;
            const offset = 4;
            const wallBuffer = 0.2;
            if (camera.position.z < -heightLimit + wallBuffer) camera.position.z = -heightLimit + wallBuffer;
            if (camera.position.z > heightLimit - wallBuffer) camera.position.z = heightLimit - wallBuffer;
            if (camera.position.x < -heightLimit + wallBuffer) camera.position.x = -heightLimit + wallBuffer;
            if (camera.position.x > heightLimit - wallBuffer && (camera.position.z < -offset / 2 || camera.position.z > offset / 2)) {
                camera.position.x = heightLimit - wallBuffer;
            }
            if (camera.position.x > heightLimit) {
                if (camera.position.z < -heightLimit + wallBuffer) camera.position.z = -heightLimit + wallBuffer;
                if (camera.position.z > heightLimit - wallBuffer) camera.position.z = heightLimit - wallBuffer;
                if (camera.position.x > 18 - wallBuffer) camera.position.x = 18 - wallBuffer;
            }
            if (camera.position.y < 2) { camera.position.y = 2; velocityY = 0; isJumping = false; }
            if (camera.position.y > wallHeight - 0.5) { camera.position.y = wallHeight - 0.5; velocityY = 0; }
        }

        function animate() {
            requestAnimationFrame(animate);
            rockets.forEach((rocket, index) => {
                rocket.mesh.position.addScaledVector(rocket.direction, rocketSpeed);
                rocket.distanceTraveled += rocketSpeed;
                raycaster.set(rocket.mesh.position, rocket.direction);
                const intersects = raycaster.intersectObjects([...walls, ...inscriptionsMeshes]);
                if (intersects.length > 0 && intersects[0].distance < rocketSpeed) {
                    const hitPoint = intersects[0].point;
                    const hitNormal = intersects[0].face.normal.clone().transformDirection(intersects[0].object.matrixWorld);
                    createTrace(hitPoint, hitNormal);
                    scene.remove(rocket.mesh);
                    rockets.splice(index, 1);
                } else if (rocket.distanceTraveled > maxRocketDistance) {
                    scene.remove(rocket.mesh);
                    rockets.splice(index, 1);
                }
            });
            if (moveForward) {
                camera.position.z -= moveSpeed * Math.cos(camera.rotation.y);
                camera.position.x -= moveSpeed * Math.sin(camera.rotation.y);
            }
            if (moveBackward) {
                camera.position.z += moveSpeed * Math.cos(camera.rotation.y);
                camera.position.x += moveSpeed * Math.sin(camera.rotation.y);
            }
            if (moveLeft) {
                camera.position.z += moveSpeed * Math.sin(camera.rotation.y);
                camera.position.x -= moveSpeed * Math.cos(camera.rotation.y);
            }
            if (moveRight) {
                camera.position.z -= moveSpeed * Math.sin(camera.rotation.y);
                camera.position.x += moveSpeed * Math.cos(camera.rotation.y);
            }
            if (isJumping) {
                camera.position.y += velocityY;
                velocityY -= gravity;
            }
            constrainCamera();
            renderer.render(scene, camera);
        }
        animate();

        addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
